// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'try_freezed.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FreezedA {}

/// @nodoc
abstract class $FreezedACopyWith<$Res> {
  factory $FreezedACopyWith(FreezedA value, $Res Function(FreezedA) then) =
      _$FreezedACopyWithImpl<$Res, FreezedA>;
}

/// @nodoc
class _$FreezedACopyWithImpl<$Res, $Val extends FreezedA>
    implements $FreezedACopyWith<$Res> {
  _$FreezedACopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FreezedACopyWith<$Res> {
  factory _$$_FreezedACopyWith(
          _$_FreezedA value, $Res Function(_$_FreezedA) then) =
      __$$_FreezedACopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FreezedACopyWithImpl<$Res>
    extends _$FreezedACopyWithImpl<$Res, _$_FreezedA>
    implements _$$_FreezedACopyWith<$Res> {
  __$$_FreezedACopyWithImpl(
      _$_FreezedA _value, $Res Function(_$_FreezedA) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FreezedA implements _FreezedA {
  _$_FreezedA();

  @override
  String toString() {
    return 'FreezedA()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_FreezedA);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _FreezedA implements FreezedA {
  factory _FreezedA() = _$_FreezedA;
}

/// @nodoc
mixin _$FreezedB {
  int get age => throw _privateConstructorUsedError;
  String get job => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FreezedBCopyWith<FreezedB> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedBCopyWith<$Res> {
  factory $FreezedBCopyWith(FreezedB value, $Res Function(FreezedB) then) =
      _$FreezedBCopyWithImpl<$Res, FreezedB>;
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class _$FreezedBCopyWithImpl<$Res, $Val extends FreezedB>
    implements $FreezedBCopyWith<$Res> {
  _$FreezedBCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_value.copyWith(
      age: null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedBCopyWith<$Res> implements $FreezedBCopyWith<$Res> {
  factory _$$_FreezedBCopyWith(
          _$_FreezedB value, $Res Function(_$_FreezedB) then) =
      __$$_FreezedBCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class __$$_FreezedBCopyWithImpl<$Res>
    extends _$FreezedBCopyWithImpl<$Res, _$_FreezedB>
    implements _$$_FreezedBCopyWith<$Res> {
  __$$_FreezedBCopyWithImpl(
      _$_FreezedB _value, $Res Function(_$_FreezedB) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_$_FreezedB(
      null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_FreezedB implements _FreezedB {
  const _$_FreezedB(this.age, {required this.job});

  @override
  final int age;
  @override
  final String job;

  @override
  String toString() {
    return 'FreezedB(age: $age, job: $job)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedB &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.job, job) || other.job == job));
  }

  @override
  int get hashCode => Object.hash(runtimeType, age, job);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedBCopyWith<_$_FreezedB> get copyWith =>
      __$$_FreezedBCopyWithImpl<_$_FreezedB>(this, _$identity);
}

abstract class _FreezedB implements FreezedB {
  const factory _FreezedB(final int age, {required final String job}) =
      _$_FreezedB;

  @override
  int get age;
  @override
  String get job;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedBCopyWith<_$_FreezedB> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FreezedC {
  int get age => throw _privateConstructorUsedError;
  String get job => throw _privateConstructorUsedError;
  set job(String value) => throw _privateConstructorUsedError;
  String? get remark => throw _privateConstructorUsedError;
  set remark(String? value) => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FreezedCCopyWith<FreezedC> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedCCopyWith<$Res> {
  factory $FreezedCCopyWith(FreezedC value, $Res Function(FreezedC) then) =
      _$FreezedCCopyWithImpl<$Res, FreezedC>;
  @useResult
  $Res call({int age, String job, String? remark});
}

/// @nodoc
class _$FreezedCCopyWithImpl<$Res, $Val extends FreezedC>
    implements $FreezedCCopyWith<$Res> {
  _$FreezedCCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
    Object? remark = freezed,
  }) {
    return _then(_value.copyWith(
      age: null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
      remark: freezed == remark
          ? _value.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedCCopyWith<$Res> implements $FreezedCCopyWith<$Res> {
  factory _$$_FreezedCCopyWith(
          _$_FreezedC value, $Res Function(_$_FreezedC) then) =
      __$$_FreezedCCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int age, String job, String? remark});
}

/// @nodoc
class __$$_FreezedCCopyWithImpl<$Res>
    extends _$FreezedCCopyWithImpl<$Res, _$_FreezedC>
    implements _$$_FreezedCCopyWith<$Res> {
  __$$_FreezedCCopyWithImpl(
      _$_FreezedC _value, $Res Function(_$_FreezedC) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
    Object? remark = freezed,
  }) {
    return _then(_$_FreezedC(
      null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
      remark: freezed == remark
          ? _value.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_FreezedC implements _FreezedC {
  _$_FreezedC(this.age, {required this.job, this.remark});

  @override
  final int age;
  @override
  String job;
  @override
  String? remark;

  @override
  String toString() {
    return 'FreezedC(age: $age, job: $job, remark: $remark)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedCCopyWith<_$_FreezedC> get copyWith =>
      __$$_FreezedCCopyWithImpl<_$_FreezedC>(this, _$identity);
}

abstract class _FreezedC implements FreezedC {
  factory _FreezedC(final int age, {required String job, String? remark}) =
      _$_FreezedC;

  @override
  int get age;
  @override
  String get job;
  set job(String value);
  @override
  String? get remark;
  set remark(String? value);
  @override
  @JsonKey(ignore: true)
  _$$_FreezedCCopyWith<_$_FreezedC> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FreezedD {
  int get age => throw _privateConstructorUsedError;
  String get job => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FreezedDCopyWith<FreezedD> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedDCopyWith<$Res> {
  factory $FreezedDCopyWith(FreezedD value, $Res Function(FreezedD) then) =
      _$FreezedDCopyWithImpl<$Res, FreezedD>;
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class _$FreezedDCopyWithImpl<$Res, $Val extends FreezedD>
    implements $FreezedDCopyWith<$Res> {
  _$FreezedDCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_value.copyWith(
      age: null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedDCopyWith<$Res> implements $FreezedDCopyWith<$Res> {
  factory _$$_FreezedDCopyWith(
          _$_FreezedD value, $Res Function(_$_FreezedD) then) =
      __$$_FreezedDCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class __$$_FreezedDCopyWithImpl<$Res>
    extends _$FreezedDCopyWithImpl<$Res, _$_FreezedD>
    implements _$$_FreezedDCopyWith<$Res> {
  __$$_FreezedDCopyWithImpl(
      _$_FreezedD _value, $Res Function(_$_FreezedD) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_$_FreezedD(
      null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_FreezedD implements _FreezedD {
  _$_FreezedD(this.age, [this.job = "nothing"]);

  @override
  final int age;
  @override
  @JsonKey()
  final String job;

  @override
  String toString() {
    return 'FreezedD(age: $age, job: $job)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedD &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.job, job) || other.job == job));
  }

  @override
  int get hashCode => Object.hash(runtimeType, age, job);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedDCopyWith<_$_FreezedD> get copyWith =>
      __$$_FreezedDCopyWithImpl<_$_FreezedD>(this, _$identity);
}

abstract class _FreezedD implements FreezedD {
  factory _FreezedD(final int age, [final String job]) = _$_FreezedD;

  @override
  int get age;
  @override
  String get job;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedDCopyWith<_$_FreezedD> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedE _$FreezedEFromJson(Map<String, dynamic> json) {
  return _FreezedE.fromJson(json);
}

/// @nodoc
mixin _$FreezedE {
  int get age => throw _privateConstructorUsedError;
  String get job => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FreezedECopyWith<FreezedE> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedECopyWith<$Res> {
  factory $FreezedECopyWith(FreezedE value, $Res Function(FreezedE) then) =
      _$FreezedECopyWithImpl<$Res, FreezedE>;
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class _$FreezedECopyWithImpl<$Res, $Val extends FreezedE>
    implements $FreezedECopyWith<$Res> {
  _$FreezedECopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_value.copyWith(
      age: null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedECopyWith<$Res> implements $FreezedECopyWith<$Res> {
  factory _$$_FreezedECopyWith(
          _$_FreezedE value, $Res Function(_$_FreezedE) then) =
      __$$_FreezedECopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int age, String job});
}

/// @nodoc
class __$$_FreezedECopyWithImpl<$Res>
    extends _$FreezedECopyWithImpl<$Res, _$_FreezedE>
    implements _$$_FreezedECopyWith<$Res> {
  __$$_FreezedECopyWithImpl(
      _$_FreezedE _value, $Res Function(_$_FreezedE) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? age = null,
    Object? job = null,
  }) {
    return _then(_$_FreezedE(
      null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
      job: null == job
          ? _value.job
          : job // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FreezedE implements _FreezedE {
  _$_FreezedE(this.age, {required this.job});

  factory _$_FreezedE.fromJson(Map<String, dynamic> json) =>
      _$$_FreezedEFromJson(json);

  @override
  final int age;
  @override
  final String job;

  @override
  String toString() {
    return 'FreezedE(age: $age, job: $job)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedE &&
            (identical(other.age, age) || other.age == age) &&
            (identical(other.job, job) || other.job == job));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, age, job);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedECopyWith<_$_FreezedE> get copyWith =>
      __$$_FreezedECopyWithImpl<_$_FreezedE>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FreezedEToJson(
      this,
    );
  }
}

abstract class _FreezedE implements FreezedE {
  factory _FreezedE(final int age, {required final String job}) = _$_FreezedE;

  factory _FreezedE.fromJson(Map<String, dynamic> json) = _$_FreezedE.fromJson;

  @override
  int get age;
  @override
  String get job;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedECopyWith<_$_FreezedE> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedF _$FreezedFFromJson(Map<String, dynamic> json) {
  return _FreezedF.fromJson(json);
}

/// @nodoc
mixin _$FreezedF {
  Map<String, int> get myMap => throw _privateConstructorUsedError;
  List<int> get myList => throw _privateConstructorUsedError;
  Set<int> get mySet => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FreezedFCopyWith<FreezedF> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedFCopyWith<$Res> {
  factory $FreezedFCopyWith(FreezedF value, $Res Function(FreezedF) then) =
      _$FreezedFCopyWithImpl<$Res, FreezedF>;
  @useResult
  $Res call({Map<String, int> myMap, List<int> myList, Set<int> mySet});
}

/// @nodoc
class _$FreezedFCopyWithImpl<$Res, $Val extends FreezedF>
    implements $FreezedFCopyWith<$Res> {
  _$FreezedFCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myMap = null,
    Object? myList = null,
    Object? mySet = null,
  }) {
    return _then(_value.copyWith(
      myMap: null == myMap
          ? _value.myMap
          : myMap // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      myList: null == myList
          ? _value.myList
          : myList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      mySet: null == mySet
          ? _value.mySet
          : mySet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedFCopyWith<$Res> implements $FreezedFCopyWith<$Res> {
  factory _$$_FreezedFCopyWith(
          _$_FreezedF value, $Res Function(_$_FreezedF) then) =
      __$$_FreezedFCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, int> myMap, List<int> myList, Set<int> mySet});
}

/// @nodoc
class __$$_FreezedFCopyWithImpl<$Res>
    extends _$FreezedFCopyWithImpl<$Res, _$_FreezedF>
    implements _$$_FreezedFCopyWith<$Res> {
  __$$_FreezedFCopyWithImpl(
      _$_FreezedF _value, $Res Function(_$_FreezedF) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myMap = null,
    Object? myList = null,
    Object? mySet = null,
  }) {
    return _then(_$_FreezedF(
      myMap: null == myMap
          ? _value._myMap
          : myMap // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      myList: null == myList
          ? _value._myList
          : myList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      mySet: null == mySet
          ? _value._mySet
          : mySet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FreezedF implements _FreezedF {
  _$_FreezedF(
      {required final Map<String, int> myMap,
      required final List<int> myList,
      required final Set<int> mySet})
      : _myMap = myMap,
        _myList = myList,
        _mySet = mySet;

  factory _$_FreezedF.fromJson(Map<String, dynamic> json) =>
      _$$_FreezedFFromJson(json);

  final Map<String, int> _myMap;
  @override
  Map<String, int> get myMap {
    if (_myMap is EqualUnmodifiableMapView) return _myMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_myMap);
  }

  final List<int> _myList;
  @override
  List<int> get myList {
    if (_myList is EqualUnmodifiableListView) return _myList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_myList);
  }

  final Set<int> _mySet;
  @override
  Set<int> get mySet {
    if (_mySet is EqualUnmodifiableSetView) return _mySet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_mySet);
  }

  @override
  String toString() {
    return 'FreezedF(myMap: $myMap, myList: $myList, mySet: $mySet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedF &&
            const DeepCollectionEquality().equals(other._myMap, _myMap) &&
            const DeepCollectionEquality().equals(other._myList, _myList) &&
            const DeepCollectionEquality().equals(other._mySet, _mySet));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_myMap),
      const DeepCollectionEquality().hash(_myList),
      const DeepCollectionEquality().hash(_mySet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedFCopyWith<_$_FreezedF> get copyWith =>
      __$$_FreezedFCopyWithImpl<_$_FreezedF>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FreezedFToJson(
      this,
    );
  }
}

abstract class _FreezedF implements FreezedF {
  factory _FreezedF(
      {required final Map<String, int> myMap,
      required final List<int> myList,
      required final Set<int> mySet}) = _$_FreezedF;

  factory _FreezedF.fromJson(Map<String, dynamic> json) = _$_FreezedF.fromJson;

  @override
  Map<String, int> get myMap;
  @override
  List<int> get myList;
  @override
  Set<int> get mySet;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedFCopyWith<_$_FreezedF> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedG _$FreezedGFromJson(Map<String, dynamic> json) {
  return _FreezedG.fromJson(json);
}

/// @nodoc
mixin _$FreezedG {
  Map<String, int> get myMap => throw _privateConstructorUsedError;
  List<int> get myList => throw _privateConstructorUsedError;
  Set<int> get mySet => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FreezedGCopyWith<FreezedG> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedGCopyWith<$Res> {
  factory $FreezedGCopyWith(FreezedG value, $Res Function(FreezedG) then) =
      _$FreezedGCopyWithImpl<$Res, FreezedG>;
  @useResult
  $Res call({Map<String, int> myMap, List<int> myList, Set<int> mySet});
}

/// @nodoc
class _$FreezedGCopyWithImpl<$Res, $Val extends FreezedG>
    implements $FreezedGCopyWith<$Res> {
  _$FreezedGCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myMap = null,
    Object? myList = null,
    Object? mySet = null,
  }) {
    return _then(_value.copyWith(
      myMap: null == myMap
          ? _value.myMap
          : myMap // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      myList: null == myList
          ? _value.myList
          : myList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      mySet: null == mySet
          ? _value.mySet
          : mySet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FreezedGCopyWith<$Res> implements $FreezedGCopyWith<$Res> {
  factory _$$_FreezedGCopyWith(
          _$_FreezedG value, $Res Function(_$_FreezedG) then) =
      __$$_FreezedGCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, int> myMap, List<int> myList, Set<int> mySet});
}

/// @nodoc
class __$$_FreezedGCopyWithImpl<$Res>
    extends _$FreezedGCopyWithImpl<$Res, _$_FreezedG>
    implements _$$_FreezedGCopyWith<$Res> {
  __$$_FreezedGCopyWithImpl(
      _$_FreezedG _value, $Res Function(_$_FreezedG) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myMap = null,
    Object? myList = null,
    Object? mySet = null,
  }) {
    return _then(_$_FreezedG(
      myMap: null == myMap
          ? _value.myMap
          : myMap // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      myList: null == myList
          ? _value.myList
          : myList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      mySet: null == mySet
          ? _value.mySet
          : mySet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FreezedG implements _FreezedG {
  _$_FreezedG({required this.myMap, required this.myList, required this.mySet});

  factory _$_FreezedG.fromJson(Map<String, dynamic> json) =>
      _$$_FreezedGFromJson(json);

  @override
  final Map<String, int> myMap;
  @override
  final List<int> myList;
  @override
  final Set<int> mySet;

  @override
  String toString() {
    return 'FreezedG(myMap: $myMap, myList: $myList, mySet: $mySet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedG &&
            const DeepCollectionEquality().equals(other.myMap, myMap) &&
            const DeepCollectionEquality().equals(other.myList, myList) &&
            const DeepCollectionEquality().equals(other.mySet, mySet));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(myMap),
      const DeepCollectionEquality().hash(myList),
      const DeepCollectionEquality().hash(mySet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FreezedGCopyWith<_$_FreezedG> get copyWith =>
      __$$_FreezedGCopyWithImpl<_$_FreezedG>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FreezedGToJson(
      this,
    );
  }
}

abstract class _FreezedG implements FreezedG {
  factory _FreezedG(
      {required final Map<String, int> myMap,
      required final List<int> myList,
      required final Set<int> mySet}) = _$_FreezedG;

  factory _FreezedG.fromJson(Map<String, dynamic> json) = _$_FreezedG.fromJson;

  @override
  Map<String, int> get myMap;
  @override
  List<int> get myList;
  @override
  Set<int> get mySet;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedGCopyWith<_$_FreezedG> get copyWith =>
      throw _privateConstructorUsedError;
}
